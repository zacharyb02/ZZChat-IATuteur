MODERN CNN ARCHITECTURES
=========================

Q1: What are the most performing modern architectures?
A:
1. Vision Transformer (ViT) - Transformers for vision
2. EfficientNet - Optimal scaling
3. ConvNeXt - Modern CNN rivaling ViT
4. Swin Transformer - Hierarchical ViT
5. MobileNet/EfficientNet - For edge devices
6. RegNet - NAS-discovered architecture

Q2: How to use EfficientNet?
A:
import torchvision.models as models

# EfficientNet-B0 (smallest)
model = models.efficientnet_b0(pretrained=True)

# EfficientNet-B7 (largest)
model_b7 = models.efficientnet_b7(pretrained=True)

# Adapt for custom classification
num_features = model.classifier[1].in_features
model.classifier[1] = nn.Linear(num_features, num_classes)

# Compound Scaling principle of EfficientNet:
# depth × width × resolution optimally balanced

Q3: How to use Vision Transformer (ViT)?
A:
class PatchEmbedding(nn.Module):
    def __init__(self, img_size=224, patch_size=16, in_channels=3, embed_dim=768):
        super().__init__()
        self.img_size = img_size
        self.patch_size = patch_size
        self.num_patches = (img_size // patch_size) ** 2
        
        self.proj = nn.Conv2d(in_channels, embed_dim, 
                             kernel_size=patch_size, stride=patch_size)
    
    def forward(self, x):
        x = self.proj(x)
        x = x.flatten(2).transpose(1, 2)
        return x

Q4: How to choose architecture based on use case?
A:
# For MAXIMUM ACCURACY (server, cloud):
model = models.efficientnet_b7(pretrained=True)

# For SPEED/EDGE (mobile, embedded):
model = models.mobilenet_v3_small(pretrained=True)

# For BALANCE (desktop, web):
model = models.efficientnet_b0(pretrained=True)

# For SMALL DATASETS:
model = models.resnet18(pretrained=True)  # Transfer learning

# For HIGH RESOLUTION (medical, satellite):
model = VisionTransformer(img_size=512, patch_size=32)
