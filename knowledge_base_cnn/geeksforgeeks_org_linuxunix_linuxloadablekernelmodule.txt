SOURCE_URL: https://www.geeksforgeeks.org/linux-unix/linux-loadable-kernel-module/
SUJET: CNN_DEEP_LEARNING

- Interview Prep
- Tutorials
- Tracks
- Linux-Unix
- Interview Questions
- Shell Scripting
- Kali
- Ubuntu
- Red Hat
- CentOS
- Docker
- Kubernetes
- Python
- R
- Java
# Linux Loadable Kernel Module
If you want to add code to a Linux kit, the basic way to do that is to add source files to the kernel source tree and assemble the kernel. In fact, the process of setting up the kernel consists mainly of selecting which files to upload to the kernel will be merged. But you can also add code to the Linux kit while it is running. A piece of code you add this way is called a loadable kernel module (LKM) . These modules can do many things, but they are usually one of three items:
The kernel separates certain functions, including these, especially well so it does not need to be encrypted across the kernel. Several parameters that a driver must know can change from system to system. These can vary from the device number to use to numerous aspects of how the driver should operate.
## Terminology
When it comes to downloadable kernel modules, they are commonly referred to as kernel modules or simply modules. However, this terminology can be misleading due to the presence of various module types with distinct components integrated into the base kernel, all of which can be rightfully considered modules. For certain module types, we prefer using the terms kernel module or LKM. Some individuals mistakenly view LKMs as separate entities from the kernel, referring to them as modules that connect to the kernel. It is important to note that if loaded, LKMs become an integral part of the kernel. The appropriate term for the kernel component associated with the image you are launching is the "base kernel." LKMs connect to the base kernel. In certain operating systems, a comparable term for Linux LKMs is a "kernel extension."
## History of LKM
Initially, loadable kernel modules were not part of the Linux framework. The functionalities we utilize as LKMs today were integrated into the base kernel during the kernel build process. However, LKMs have been in existence since at least Linux 1.2 (1995). Device drivers and other components were always designed in a modular fashion. When LKMs were introduced, a certain amount of effort was required to convert these components into LKMs, which was a time-consuming task. Since around 2000, there has been a growing trend to make nearly everything compatible with LKMs, providing the option to use them.
## The Case for LKM
You often have the choice between installing a module in a kernel by uploading it as LKM or committing to it. base kernel. LKM has many benefits in addition to binding to the basic kernel. Another advantage is that you do not need to rebuild your kernel often. This saves time and saves you. you may have made a mistake in restructuring and refining the base kernel. Once you have a job base kernel, it is best to leave it untouched for as long as possible. Another advantage is that LKM helps you diagnose system problems. Disruption to the device driver in the kernel can stop your system from running at all. And it can be very difficult to say which part of the foundation kernel created a problem. If the driver of the same LKM device, however, the base kernel is active again before the device driver is loaded. It is easy to track a problem when your system dies once you turn on/off the base kernel until the device driver causes the problem and we do not load the device drive until we fix the problem.
LKMs can save your memory because you should only download them if you really use them. All parts of the base kernel are loaded at all times - in real storage, not virtual storage. LKMs are very quick to maintain and repair. What may require a full restart to be done with the file system driver built into the kernel, you can do it with a few quick commands with LKM. You can try different parameters or change the code repeatedly in quick succession, without waiting for the boot. LKMs do less, by the way, than base kernel modules. Calling anywhere is just a branch in the place of memory where it resides. Sometimes you have to build something in the base kernel instead of making it LKM. Anything that exists that is needed to move the system far enough to load LKMs should obviously be built into the base kernel.
## What are LKMs used for?
Let's look at the major 6 LKMs used.
- Device drivers: The device driver is designed for a specific piece of hardware. The kernel uses it to contact that piece of hardware without knowing any hardware details it works. For example, there is an ATA disk drive device driver. There is one for the NE2000 compatible Ethernet cards. In order to use any device, the kernel must contain a driver for its device.
- Filesystem drivers: The file system driver interprets the contents of the file system such as files and references and more. There are a lot of ways to save files and references. By all means, you need a file system driver. For example, there is an ext2 file type file system driver used almost all over the world on Linux disk drives. There is also one MS-DOS file system, as well as one NFS.
- System calls: Userspace applications use system calls to access resources in the kernel. For example, there are system calls to read the file, create a new process, and close the program. Most System phones are part of the system and are state-of-the-art, so they are always built into the base kernel (no LKM option). But you can configure your system phone and install it as LKM. Or you can decide you don't like the way Linux does something and issue an existing system call with Your LKM.
- Network drivers : The network operator interprets the network protocol. It feeds and consumes data streams at various stages of kernel communication activity. For example, if you want an IPX link to your own network, you will use an IPX driver.
- TTY line instructions : This is actually an upgrade of device drivers to storage devices.
- Useful interpreters: Usable translator uploads and uses usable. Linux is designed for that to be able to use in a variety of formats, and each must have its own usable translator.
## Compiling Kernel Modules
The below example shows how our kernel module gets parameters from users at load time by insmod or modprobe command .
Example Code:
```python
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/module.h>
static char* whoisthis = "Mommy";
static int countpeople = 1;
module_param(countpeople, int, S_IRUGO);
module_param(whoisthis, charp, S_IRUGO);
static int __init m_init(void)
{
pr_debug("parameters test module is loaded\n");
for (int i = 0; i < countpeople; ++i) {
pr_info("#%d Hello, %s\n", i, whoisthis);
}
return 0;
}
static void __exit m_exit(void)
{
pr_debug("parameters test module is unloaded\n");
}
module_init(m_init);
module_exit(m_exit);
M ODULE_LICENSE("GPL");
```
### Shell:
Build the module. To build this module, execute:
bash make KERNELDIR=/path/to/kernel/source/dir
If you have already set and exported the `KERNELDIR` environment variable, simply executing ` make ` is enough.
### Usage:
Copy the object file **hello_world.ko** to the target machine, then run:
```python
bash insmod module_parameters.ko
```
Running `dmesg | tail -10`, you can find something like this:
[ 1223.506799] parameters test module is loaded [ 1223.509953] #0 Hello, Mommy
It is right that by default, we set to print **hello, Mommy** only one time. Next, we unload this module and pass parameters to it when loading.
bash # Unloading using rmmod command rmmod module_parameters # Reloading the module and passing parameters to itre-load the module and passing parameters to it insmod module_parameters.ko whoisthis=dady countpeople=3
This time, the message is changed:
```python
[ 1322.364784] parameters test module is loaded[ 1322.366768] #0 Hello, dady[ 1322.367999] #1 Hello, dady[ 1322.369154] #2 Hello, dady
```
## Conclusion
In this article we have discussed loadable kernel modules (LKMs) provide a flexible and efficient way to extend the Linux kernel. They enable dynamic code addition and removal while the system is running, offering benefits such as flexibility, modular development, and easy debugging. LKMs are commonly used for device drivers, file system drivers, and system calls. They save memory, connect to the base kernel, and have become a standard option for enhancing the Linux kernel since their introduction in the mid-1990s.
### Explore
- Introduction to Linux Operating System 7 min read
- LINUX Full Form -  Lovable Intellect Not Using XP 2 min read
- Difference between Linux and Windows 7 min read
- Linux Distributions 6 min read
- Difference between Unix and Linux 6 min read
- Installation of Arch Linux in VirtualBox 4 min read
- Fedora Linux Operating System 5 min read
- How to install Ubuntu on VirtualBox? 6 min read
- How to Install Linux Mint? 3 min read
- Installation of Kali Linux in Virtual Machine 2 min read
- How to Install Linux on Windows PowerShell Subsystem? 2 min read
- How to Find openSUSE Linux Version? 2 min read
- Installation of CentOS 2 min read
- Linux Commands 15+ min read
- Essential Unix Commands 7 min read
- Find Command in Linux 7 min read
- Linux File System 12 min read
- Linux File Hierarchy Structure 5 min read
- Linux Directory Structure 6 min read
- Linux Kernel 4 min read
- Kernel in Operating System 3 min read
- How Linux Kernel Boots? 11 min read
- Difference between Operating System and Kernel 3 min read
- Linux Kernel Module Programming: Hello World Program 7 min read
- Linux Loadable Kernel Module 7 min read
- Loadable Kernel Module - Linux Device Driver Development 4 min read
- Network configuration and troubleshooting commands in Linux 5 min read
- How to configure network interfaces in CentOS? 5 min read
- Command-Line Tools and Utilities For Network Management in Linux 8 min read
- Linux - Network Monitoring Tools 4 min read
- Processes in Linux/Unix 5 min read
- How to Manage Process in Linux 4 min read
- Getting System and Process Information Using C Programming and Shell in Linux 2 min read
- Process states and Transitions in a UNIX Process 4 min read
- LINUX Firewall 7 min read
- iptables command in Linux with Examples 7 min read
- How to Configure your Linux Firewall - 3 Methods 12 min read
- Introduction to Linux Shell and Shell Scripting 7 min read
- Understanding Terminal, Console, Shell and Kernel 3 min read
- How to Create a Shell Script in linux 7 min read
- Shell Scripting - Different types of Variables 4 min read
- Bash Scripting - Introduction to Bash and Bash Scripting 12 min read
- Bash Script - Define Bash Variables and its types 12 min read
- Shell Scripting - Shell Variables 6 min read
- Bash Script - Difference between Bash Script and Shell Script 4 min read
- Shell Scripting - Difference between Korn Shell and Bash shell 3 min read
- Shell Scripting - Interactive and Non-Interactive Shell 3 min read
- Shell Script to Show the Difference Between echo “$SHELL” and echo ‘$SHELL’ 4 min read
- What is Linux System Administration? 6 min read
- Beginner's Guide to Linux System Administration 5 min read
- How to Monitor System Usage, Outages and Troubleshoot Linux Servers 6 min read
- Linux - Systemd and its Components 3 min read
- Boot Process with Systemd in Linux 3 min read
- How to Control Systemd Services on Remote Linux Server 2 min read
- How to Start, Stop and Restart Services in Linux Using systemctl Command 9 min read